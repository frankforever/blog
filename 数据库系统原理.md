# **数据库系统原理**

## **第二章**

数据模型是一个包含数据、数据联系、数据语义以及一致性约束的概念工具的合集。

数据模型包括：

关系模型、实体-联系模型（E-R）、基于对象的数据模型、半结构化数据模型。

关系模式属于中，关系指代表，元组指代行，属性指代列。

对于关系的每个属性，都存在一个取值集合，称为属性的域。

超码是一个或多个属性的集合，可以在关系中唯一标识一个元组。

候选码

主码

## **第三章**

nvarchar数据类型，unicode编码可变长度类型，最大值4000，支持多语言。

SQL禁止破坏完整性约上的任意数据库更新。

```sql
drop table r;    --删除关系r
delete table r;  --删除关系r的所有元组，但是关系r保留

select distinct name 
from instructor;  --去除重复查询结果
```

**自然连接**

```sql
select name, course_id
from instructor, teaches
where instructor.ID = teachers.ID;
用自然连接简写为：
select name, course_id
from instructor natural join teaches;
```

join···using···用法

```sql
select name, title
from instructor natural join teaches, course
where teaches.course_id = course.course_id;
等价于
select name, title
from (instructor natural join teaches) join course using (course_id);
```

更名运算 `as`, Oracle中可省略。

相关名称

SQL标准中字符串相等运算大小写敏感，在MySQL和SQL server中大小写不敏感。

字符串上可以使用 `like`操作符来实现模式匹配。`%`：匹配任意字符，`_`：匹配任意一个字符。

可使用 `escape` 关键字来定义转义字符。

```sql
select dept_name
from department
where building like '%ab\%\\cd%' escape '\' ;
--选取以ab%\cd为开头的名字
```

`*` 表示所有属性。

```sql
select instructor.*
from instructor as I, teaches as T
where I.id = T.id;
```

`oder by`定义显示次序，`dsec` 表示降序， `sec` 表示升序。

```sql
select *
from instructor
order by salary dsec, name sec;
```

```sql
select name
from instructor
where salary between 9000 and 10000;
```

```sql
select name, course_id
from instructor, teaches
where (instructor.ID, dept_name) = (teaches.ID, 'Biology');
```

`union`（并）运算自动去重复：(`union all`可保留左右重复元组)

```sql
(select course_id
 from section 
 where semester = 'Fall' and year = 2009)
 union
(select course_id
 from section
 where semester = 'Spring' and year = 2010);
```

`intersect`（交）运算也自动去重复，`intersect all`同上

`except`（差）运算，第一个减第二个，运算前去重复。`except all`同上。

**`except`可用于检测两个查询结果是否相同。**

如果算术表达式的任一输入为空，则结果为空。

unknow为第三种逻辑。

```sql
and: true and unknow:true, false and unknow: unknow, unknow and unknow: unknow
or: true or unknow : true, false or unknow : unknow, unknow or unknow:unknow
not: not unknow : unknow
```

谓词中 `null = null` 会返回`unknow`

**聚集函数**

```sql
--包含avg, sum, count, min, max
select avg(salary) as avg_salary
from instructor
where dept_name = 'Comp.Sci.';    --保留重复元组很重要
--去重复元组情况：
select count(distinct ID)
from teaches
where semester = 'Spring' and year = 2010;
--计算一个关系中的元组数：
select count(*)
from course;
--分组聚集使用group by
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name;
--having子句可对分组进行约束
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name
having avg_salary > 42000;
```

空集的count运算为0，其他聚集运算输入空集后返回空集。

至少比某一个大用 `>some`表示（`any`同义与`some`），还有

`<some, >=some, <=some, <>some, =some`

比所有都大用`>all`表示，还有

`<all, >=all, <=all, =all, <>all`

比较一组查询方法，相同结果：

```sql
select distince course_id
from section
where semester = 'Fall' and year = 2009 and
	course_id in(select course_id
                  from section
                  where semester = 'Spring' and year = 2010);
                  
selecct course_id
from section as S
where semester = 'Fall' and year = 2009 and
	exists (select *
             from section as T
             where semester = 'Spring' and year = 2010 and 
           		S.course_id = T.course_id);
```

`not exists`结构模拟包含操作， `not exists(B except A)`即关系A包含关系B

布尔函数`unique`可用于测试一个子查询中是否存在重复元组，若无，返回真值。

`with`子句可定义临时关系。

## **第四章 中级SQL**

join on

```sql
select*
from student join takes on student.ID = takes.ID;
同
select*
from student natural join takes;
同
select*
from student, takes
where student.ID = takes.ID;
```

外连接

```sql
select*
from student natural left outer join takes;
同
select*
from takes natural right outer join sturent;
```

通过外连接查询没有选修课程的学生：

```sql
select id
from student natural left outer join takes
where course_id is null;
```

on和where的区别：

```sql
#on属于外连接声明的一部分，外连接是作用是为那些对相应内连接没有贡献的元组补上空值并加入结果
#on条件不为真的结果也会返回并补上空值加入结果
select*
from student left outer join takes on student.ID = takes.ID;
#where属于生成两个关系笛卡尔积后进行的过滤条件
select*
from student left outer join takes on true
where student.ID = takes.ID;
```

on,where,having速度递减，on属于连接时使用，where属于计算时使用，having属于计算后使用。

任何不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为**视图**。

使用用命令`create view`定义。才需要的时候才被创建。

```sql
create view physics_fall_2009 as
select course.course_id, sec_id, building, room_number
from course, section
where course.course_id = section.course.id
	and course.dept_name = 'Physics'
	and section.semester = 'Fall'
	and section.year = '2009';
	
#视图在数据库系统中存储其定义本事，不存储执行结果，一旦视图出现在查询中，则根据其存储的查询表达式进行计算
create view physics_fall_2009_watson as
	select course_id, room_number
	from physics_fall_2009
	where building = 'Watson';
```

物化视图：如果用于定义视图的实际关系改变，视图也会跟着改变。

**事务**（transaction）由查询和（或）更新语句的序列组成。SQL标准规定当一条SQL语句被执行，就隐式的开始了一个事务。

很多SQL实现中默认单一SQL语句自成一个事务。若一事务有多条语句则需要频繁关闭自动提交。SQL1999标准中规定（仅一些SQL实现支持）:允许多条预警包含在关键字`begin···atomic···end`中。

**完整性约束**保证授权用户对数据库所做的修改不会破坏数据的一致性。

完整性约束可在`create table`命令中包含，也可以通过`alter table table-name add constrait`施加到已有关系上。

```sql
#create table允许包括的完整性约束有：
not null
unique
check(谓词)
```

SQL支持使用`reference`显式指定被参照关系的属性列表，这个被指定的属性列表必须用``primary key`或`unique`声明被参照关系的候选码。

`initially deferred`子句可指定一个完整性约束检查为可延迟的。

断言的形式为：

`create assertion <assertion-name> check <predicate>;`

```sql
create assertion credits_earned_constraint check
	(not exists (select ID
                from sudent
                where tot_cred <> (select sum(credits)
                                   from takes natural join course
                                   where student.ID = takes.ID
                                   and grade is not null and grade <> 'F')
                )
    );
```

自定义数据类型

```sql
create type Dollars as numeric(12,2) final;

create table department
	（dept_name varchar(20),
	building varchar (15),
	budget Dollars);
	
cast(department.budget to numeric(12,2));	#类型转换
```

create domin定义一个域。域上可以声明约束，一个域类型的值可以被赋给另一个域类型，只要基本类型相同。

PostgreSQL支持create domin结构， create type结构具有不同的语法和解释。

```sql
create table like temp_instructor like instructor	#声明一个与intructor具有相同模式的															#temp_instructor
```

`create schema`和`drop schema`用于创建和删除模式

```sql
--用grant语句来授予权限。
grant <权限列表>
on <关系名或视图名>
to <用户/角色列表>

--包括的操作有
select
insert
update

--用rovoke语句收回权限
revoke <权限列表>
on <关系名或视图名>
from <用户/角色列表>
```

角色可以很好的管理权限

```sql
create role instructor;
#给角色授权
grant select o takes
to instructor;
#角色授予用户
grant dean to Amit;
create role dean;
grant instructor to dean;
grant dean to Satoshi;
#给视图授权
create view geo_instructor as
	(select*
     from instructor
     where dept_name = 'Geoglogy');
#创建视图的用户不能超越没有给其授权的权限
```

reference权限允许用户在创建关系时声明外码。

添加`with grant option`可以在授予权限时规定获得此权限的用户/角色可将权限再授予其他角色。

收回权限时可声明restrict来防止级联收回`revoke select on department from Amit, Satoshi restrict;`

关键词`cascade`表示需要级联收回。

## **第五章 高级SQL**

JDBC

ODBC示例

```c
void ODBCexample(){
    RETCODE error;
    HENV env;
    HDBC conn;
    
    SQLAllocENV(&env);
    SQLAllocConnect(env, &conn);
    SQLConnect(conn, "db.yale.edu", SQL_NTS, "avi", SQL_NTS, "avipasswd", SQL_NTS);
    {
        char deptname[80];
        float salary;
        int lenOut1, lenOut2;
        HSTMT stmt;
        
        char* sqlquery = "select dept_name, sum(salary) from instructor group by dept_name";
        SQLAllocStmt(conn, &stmt);
        error = SQLExecDirect(stmt, sqlquery, SQL_NTS);
        if(error == SQL_SUCCESS){
            SQLBindCol(stmt, 1, SQL_C_CHAR, deptname, 80, &lenOut1);
            SQLBindCol(stmt, 2, SQL_C_FLOAT, &salary, 0, &lenOut2);
            while(SQLFetch(stmt) == SQL_SUCCESS){
                printf("%s%g\n", deptname, salary);
            }
        }
        SQLFreeStmt(stmt, SQL_DROP);
    }
    SQLDisconnect(conn);
    SQLFreeConnect(conn);
    SQLFreeEnv(env);
}
```

SQL标准定义了**调用级接口**（Call Level Interface, CLI），与ODBC接口类似。

为了使预处理器识别嵌入式SQL请求， 使用EXEC SQL语句。嵌入式SQL依赖宿主语言。

```sql
EXEC SQL
	declare c cursor for
	select ID, name
	from student
	where tot_cred >:credit_amount;
--c为查询游标
EXEC SQL open c;
```

`EXEC SQL COMMIT`提交事务，用`EXEC SQL ROLLBACK`进行回滚。

```sql
--sql中定义的函数
create function dept_count(dept_name varchar(20))
	returns integer
	begin
	declare d_count integer;
		select count(*) into d_count
		from instructor
		where instructor.dept_name = dept_name
	return d_count;
	end
```

表函数（返回关系作为结果的函数）

```sql
--sql中定义的表函数
create function instructor_of(dept_name varchar(20))
	returns table(
    	ID varchar(5),
    	name varchar(20),
    	dept_name varchar(20),
    	salary numeric(8,2))
return table
	(select ID, name, dept_name, salary
     from instructor
     where instrucotr.dept_name = instrucotr_of.dept_name);
```

SQL也支持过程。

```sql
create procedure dept_count_proc(in dept_name varchar(20), out d_count integer)
	begin
		select count(*) into d_count
		from instructor
		where instructor.dept_name = dept_count_proc.dept_name
	end
```

关键字**in**和**out**分别表示待赋值的参数和为返回结果而在过程中设置值的参数。

使用**call**语句调用过程。

使用**declare**语句声明变量。

begin···end语句之间可以用signal引发异常，用continue继续从引发异常的语句的下一条语句执行。

Microsoft SQL Server允许过程编译成通用语言运行程序（CLR）来在数据库过程中执行，可使用C#，VB语言。

PostgreSQL支持Perl, Python, Tcl等语言中定义函数。

**触发器**是一条当数据库发生修改时，自动被系统执行的语句。

`referencing new row as nrow`建立一个变量nrow（过渡变量），用来在插入完成后存储所插入行的值，还可以用于更新操作。

`referencing old row as`可以建立一个变量用来存储已经更新或删除行的旧值。

```sql
create trigger timeslot_check1 after insert on section
	referencing new row as nrow
	for each row 		--可以显示的在每一个被插入的行上进行迭代。
	when (nrow.time_slot_id not in (			--满足when条件才会执行触发器其余部分。
    							  select time_slot_id
    							  from time_slot))
    begin
    	rollback		--插入不合法time_slot_id时回滚
    end;
    
create trigger timeslot_check2 after delete on time_slot
	referencing old row as orow
	for each row
	when （orow.time_slot_id not in (
    							   select time_slot_id
    							   from time_slot)
    and orow.time_slot_id in (
    						select time_slot_id
    						from section))
    begin
    	rollback
    end;
```

以上为触发器在(update, insert, delete)之后出发，下面为触发器在事件之前触发

```sql
create trigger sentnull before update of takes
	referencing new row as nrow
	for each row
	when(nrow.grade = ' ')
	begin atomic
		set nrow.grade = null
	end;
```

`alter trigger trigger_name disable`(或`disable trigger trigger_name`)将触发器设为无效。

`drop trigger trigger_name`可丢弃触发器。

with recursive定义递归。

```sql
with recursive rec_prereq(couse_id, prereq_id) as (
			select course_id prereq_id)
			from prereq
		union
			select rec_prereq.course_id, prereq.prereq_id
			from prereq, rec_prereq
			where prereq.course_id = rec_prereq.prereq_id
		)
select *
from rec_prereq;
```

SQL要求查询必须是单调的。

分区：

```sql
select ID, dept_name
	rank() over(partition by dept_name order by GPA desc) as dept_rank
from dept_grades
order by dept_name, dept_rank;
```

limit子句：

```sq
select ID, GPA
from sutdnet_grades
order by GPA
limit 10;	--输出前十，limit不支持分区
```

OLAP概念，转轴，切片，上卷，下钻。

SQL中使用pivot子句，用于创建交叉表。

```sql
select *
from sales
pivot (
	sum (quantity))
	for color in ('dark', 'pastel', 'white')
)
order by item_name;
```

decode函数用来对元组中的属性进行值的替换。大体形式是：

```sql
decode(value, match-1, replacement-1, match-2, replacement-2,...match-N, replacement-N, 			default_replacement)
```

decode将value 与match匹配，若发现匹配，就用相应的替代值替换，若没有匹配，就用默认的替代值替换属性值。

## 第六章 形式化关系查询语言

### 关系代数

选择、投影、更名为一元运算。关系代数中的选择对应于SQL中的where。

选择（select）用$\sigma$表示。$\sigma_{dept\_name="Physics"}(instructor)$

谓词包括$= ,\neq,\leq, \geq, >, <$，还可以用连词and（$\land$）, or（$\lor$）, not（$\lnot$）

投影用$\Pi$表示，$\Pi_{ID, name, salary}(instructor)$

更名用$\rho$表示，$\rho_x(E)$表示将表达式E更名为x，若表达式E是n元的

$\rho_{x(A_1,A_2,A_3,...,A_n)}(E)$表示将E更名为X，并给各属性更名为$A_1,A_2,...,A_n$

自然连接用$\Join$表示。

聚集用$\mathcal{G}$表示，$\mathcal{G}_{sum(salary)}(instructor)$

$\exists t\in r(Q(t)$ 表示关系r中存在元组t使得谓词Q(t)为真。

$\lnot \exists u\in section(...)$ 子句表示不存在section中的u。

$P\Rightarrow Q$ 表示P蕴含Q。

$\forall t\in r(Q(t))$ 表示对关系r中的所有元组t， Q均为真。

没有任何一个元组关系演算等价于聚集运算。

