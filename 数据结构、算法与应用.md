# **数据结构、算法与应用**

## 						C++语言描述

### **第一部分：C++基础**

采用模板函数，简化程序长度。

常量引用采用关键字`const`。

```c++
template<class Ta, class Tb, classTc>
Ta abc(const Ta& a, const Tb& b, const Tc&,c){
	return a+b*c;
}
```

`const`型引用返回？

动态存储空间分配

`int* y = new int[n];`

二维数组必须指定第二维大小。

$\mathcal O(n) $  表示渐近小于或等于，表示渐近上界

$\Omega(n)$  表示渐近大于或等于，表示渐近下界

$\Theta(n)$  表示渐近等于，表示渐近边界

$\mathcal o(n)$  表示非紧的上界

$\omega(n)$ 表示非紧的下界

![说明](C:\project\blog\assets/1357827169_2899.jpg)

> 拷贝构造函数相关：
>
> 拷贝初始化不仅在使用“=”定义变量时发生，也在下列情况发生：
>
> - 将一个对象作为实参传递给一个非引用型的形参
> - 从一个返回类型为非引用类型的函数返回一个对象
> - 用花括号列表初始化一个数组的元素或一个聚合类中的成员

一个抽象类的派生类，只有在实现了基类的所有纯虚函数才是具体类，否则依然是抽象类而不能实例化。

类的成员函数如果不在类声明体内部实现，而是在外部实现，就必须使用作用域说明符。`::`

> 复制构造函数（拷贝构造函数）需要用引用来实现从现有的相同类型的对象中产生新的对象。
>
> 引用一旦被初始化为指向一个对象，则不能改变为另一个对象的引用，与指针不同。
>
> 引用&就是能自动的被编译器间接引用的常量型指针。
>
> 引用为对象起了另外一个名字。
>
> 引用本身不是一个对象。

**赋值永远改变的是等号左边的对象。**

> 涉及指针或引用的声明有两种写法：
>
> 一、修饰符与变量标识符写一起`int *p` 着重强调变量具有复合类型
>
> 二、修饰符与类型名写一起`int* p` 着重强调本次声明定义了一种复合类型

```c++
int i = 42;
int* p;
int* &r = p;	//指向指针的引用，从右向左读定义
r = &i;
*r = 0;
```

顶层const可以表示任意对象是常量。

```c++
const int ci = 42;	//顶层const
const int *p2 = &ci;	//底层const
```

编译文件：

`CC -c factMain.cc # generates factMain.o`

> 如果函数无需改变引用形参的值，最好将其声明为常量引用。

数组引用形参：

```c++
void print(int (&arr)[10]){
    for(auto elem:arr)
        cout << elem << endl;
}
//f(int (&arr)[10]), &arr两端括号必不可少。
```

main处理命令行选项
`prog -d -o ofile data0`

这些命令行通过两个可选的形参传递给main函数

`int main(int argc, char* argv[])`

`int main(int argc, char** argv)`

成员访问运算符包括`.`和`->`

```c++
ptr->mem
//等价于
(*ptr).mem
```



### **第二部分 数据结构**

原地反转链表：

```c++
// reverse
template<class T>
chainNode<T>* chain<T>::reverse(chainNode<T>* pre, chainNode<T>* cur){
  if(cur == NULL){
    return NULL;
  }
  chainNode<T>* nextNode = cur->next;
  cur->next = pre;
  if( nextNode!=NULL ){
    reverse(cur, nextNode);
  } else {
    this->firstNode = cur;  //reset firstNode
    return cur;
  }
}

//单参数递归
template <class T>
chainNode<T>* chain<T>::reverse(chainNode<T>* head) {
  if (head == NULL) {
    return head;
  }
  
  chainNode<T>* nextNode = head->next;
  if (nextNode == NULL) {
    firstNode = head;
    return head;
  }

  head->next = NULL;
  chainNode<T>* nextHead = reverse(nextNode);
  nextNode->next = head;
  return nextHead;
}
```

友元函数

见matrix.h

二维矩阵声明，数据按行主次序映射到一维数组中。

栈折叠问题？

#### **第八章栈**

栈LIFO（last in first out）

递归函数调用时使用递归工作栈，包括返回地址、被调函数的局部变量和形参的值。

```c++
//汉诺塔递归解法
void towersOfHanoi(int n, int x, int y, int z){
  //x move to y
  if(n>0){
    towersOfHanoi(n-1, x, z, y);
    cout << "Move top disk from tower " << x << " to top of tower " << y<<endl;
    towersOfHanoi(n-1, z, y, x);
  }
  //x move to z
  // if(n>0){
  //   towersOfHanoi(n-1, x, z, y);
  //   cout << "Move top disk from tower " << x << " to top of tower " << z <<endl;
  //   towersOfHanoi(n-1, y, x, z);
  // }
}
```

#### 第九章队列

队列FIFO（first in first out）

